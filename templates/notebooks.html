{% extends "base.html" %}
{% block content %}
<h2>Jupyter Notebooks (Lite)</h2>
<p class="muted">
  Your work is saved to your account when you click <em>Save to Server</em> or use Jupyter’s Save (Ctrl+S).
</p>

<div style="margin:0 0 10px 0;">
  <button id="saveBtn" class="btn">Save to Server</button>
  <a class="btn" href="{{ url_for('my_notebooks_page') }}">My Notebooks</a>
  <span id="status" style="margin-left:10px;color:#9ecbff;"></span>
</div>

<div style="height:82vh;">
  <iframe
    id="jlite_frame"
    title="JupyterLite"
    src="about:blank"
    style="width:100%;height:100%;border:0"
    allow="clipboard-read; clipboard-write">
  </iframe>
</div>

<script>
(function(){
  const STATUS = document.getElementById('status');
  const frame = document.getElementById('jlite_frame');
  const sleep = ms => new Promise(r => setTimeout(r, ms));
  let serverSaveBusy = false;
  let initHooksDone = false;

  function setStatus(msg, isError=false, ttl=3000){
    STATUS.textContent = msg || '';
    STATUS.style.color = isError ? '#ff8a80' : '#9ecbff';
    if (msg && ttl) setTimeout(()=>{ STATUS.textContent=''; }, ttl);
  }

  async function getMe(){
    try{
      const r = await fetch("/api/me", {credentials:"same-origin"});
      if(!r.ok) return null;
      return await r.json();
    }catch(_){ return null; }
  }

  // Per-student isolation at entry (same as before)
  async function ensurePerUserStorage(){
    const me = await getMe(); if(!me) return;
    const KEY = "chalk_student_id_v4";
    const now = String(me.id), prev = localStorage.getItem(KEY);
    if (prev === now) return;

    await clearJupyterLiteStorage();
    localStorage.setItem(KEY, now);
  }

  // ALSO clear storage when leaving /notebooks (prevents “duplicates on reopen”)
  async function clearJupyterLiteStorage(){
    try{
      if (typeof indexedDB.databases === 'function') {
        const dbs = await indexedDB.databases();
        for (const db of dbs) if (db && db.name) {
          await new Promise(res => {
            const req = indexedDB.deleteDatabase(db.name);
            req.onsuccess = req.onerror = req.onblocked = () => res();
          });
        }
      } else {
        for (const name of [
          "JupyterLite Storage","JupyterLite","JupyterLite v1",
          "JupyterLite Contents","JupyterLab Workspaces","jupyterlite","jp-contents"
        ]) {
          await new Promise(res => {
            const req = indexedDB.deleteDatabase(name);
            req.onsuccess = req.onerror = req.onblocked = () => res();
          });
        }
      }
    }catch(_){}

    try{
      if ('caches' in window) {
        const keys = await caches.keys();
        for (const k of keys) if (k.toLowerCase().includes('jupyter')) {
          await caches.delete(k).catch(()=>{});
        }
      }
    }catch(_){}

    try{
      for (const k of Object.keys(localStorage)) if (/jupyter|jp-|jupyterlab|jupyterlite/i.test(k)) localStorage.removeItem(k);
      for (const k of Object.keys(sessionStorage)) if (/jupyter|jp-|jupyterlab|jupyterlite/i.test(k)) sessionStorage.removeItem(k);
    }catch(_){}
  }

  // clear on exit (best-effort)
  window.addEventListener('pagehide', () => { clearJupyterLiteStorage(); });
  window.addEventListener('beforeunload', () => { clearJupyterLiteStorage(); });

  // Wait for JupyterLite app to be fully ready
  async function waitForAppReady(maxMs=60000){
    const win = frame.contentWindow;
    const start = Date.now();
    while (Date.now() - start < maxMs){
      const app = win && win.jupyterapp;
      if (app && app.serviceManager && app.serviceManager.ready){
        try { await app.serviceManager.ready; } catch(_){}
        return app;
      }
      await sleep(100);
    }
    return null;
  }

  function baseName(pth){ return (pth || '').split('/').pop() || 'Untitled.ipynb'; }
  function sanitizeName(name){
    let n = (name || 'Untitled').trim();
    n = n.replace(/[\\\/:*?"<>|]/g, '-');
    if (!n.toLowerCase().endsWith('.ipynb')) n += '.ipynb';
    return n;
  }

  async function getCSRF(){
    const r = await fetch("/api/csrf", {credentials:"same-origin"});
    const j = await r.json(); return j.csrf;
  }

  // Clean the workspace before opening a notebook (so only that file shows)
  async function cleanWorkspace(app){
    const contents = app.serviceManager.contents;
    async function deleteTree(path){
      const model = await contents.get(path || '', {content: true}).catch(()=>null);
      if (!model) return;
      if (model.type === 'directory'){
        for (const child of (model.content || [])){ await deleteTree(child.path); }
        if (path) await contents.delete(path).catch(()=>{});
      } else if (path) {
        await contents.delete(path).catch(()=>{});
      }
    }
    const root = await contents.get('', {content:true}).catch(()=>null);
    if (root && Array.isArray(root.content)){
      for (const item of root.content){ await deleteTree(item.path); }
    }
  }

  // Import server notebook by id with the CORRECT filename
  async function importFromServer(app, nbId){
    await cleanWorkspace(app);
    const r = await fetch(`/api/notebooks/${nbId}`, {credentials:"same-origin"});
    if(!r.ok){ setStatus("Could not load notebook.", true); return; }
    const data = await r.json();
    const nb = data.content || {};
    nb.metadata = nb.metadata || {};
    nb.metadata.chalk_id = nbId;

    // Prefer server-provided filename, else metadata, else a safe fallback
    const desired = sanitizeName(data.name || nb.metadata.chalk_name || `Notebook-${nbId}.ipynb`);

    // If a file with the same name exists (shouldn't after clean), remove it
    const contents = app.serviceManager.contents;
    await contents.delete(desired).catch(()=>{});

    await contents.save(desired, {type:"notebook", format:"json", content: nb});
    await app.commands.execute('docmanager:open', { path: desired });
    setStatus("Notebook loaded.", false, 2000);
  }

  // Save active notebook to server; stores filename in metadata.chalk_name
  async function saveActiveToServer(app, {ensureJupyterSaved} = {ensureJupyterSaved:true}){
    if (serverSaveBusy) return;
    const w = app.shell.currentWidget;
    if(!w || !w.context || !w.context.path){
      setStatus("No active notebook.", true); return;
    }
    try{
      serverSaveBusy = true;

      if (ensureJupyterSaved) { await w.context.save(); }
      await sleep(180); // let Jupyter flush to contents service

      const path = w.context.path;
      const model = await app.serviceManager.contents.get(path, {content:true, type:"notebook", format:"json"});
      const nb = model && model.content;
      if(!nb){ setStatus("Could not read notebook JSON.", true); return; }

      const chosen = sanitizeName(baseName(path));
      nb.metadata = nb.metadata || {};
      nb.metadata.chalk_name = chosen;   // <- persist student's filename

      const csrf = await getCSRF();
      const chalkId = nb.metadata.chalk_id;

      if(!chalkId){
        const r = await fetch("/api/notebooks", {
          method: "POST",
          headers: {"Content-Type":"application/json","X-CSRF": csrf},
          credentials: "same-origin",
          body: JSON.stringify({ content: nb })
        });
        if(!r.ok){ setStatus("Create failed.", true); return; }
        const j = await r.json();
        nb.metadata.chalk_id = j.id;

        // write back metadata (id + name) so subsequent saves update the same row
        await app.serviceManager.contents.save(path, {type:"notebook", format:"json", content: nb});
        setStatus(`Saved (new): ${chosen}`, false, 2000);
      } else {
        const r = await fetch(`/api/notebooks/${chalkId}`, {
          method: "PUT",
          headers: {"Content-Type":"application/json","X-CSRF": csrf},
          credentials: "same-origin",
          body: JSON.stringify({ content: nb })
        });
        if(!r.ok){ setStatus("Update failed.", true); return; }
        setStatus(`Saved: ${chosen}`, false, 1500);
      }
    } catch(e){
      console.error(e);
      setStatus("Save failed.", true);
    } finally {
      serverSaveBusy = false;
    }
  }

  // Hook Jupyter saves & renames so filename changes persist
  function installSaveHooks(app){
    if (initHooksDone) return;
    initHooksDone = true;
    const cmds = app.commands;
    if (cmds && cmds.commandExecuted && cmds.commandExecuted.connect){
      cmds.commandExecuted.connect((_sender, args) => {
        const id = args && args.id;
        if (id === 'docmanager:save' || id === 'docmanager:save-as' || id === 'docmanager:save-all' || id === 'docmanager:rename'){
          // After Jupyter finishes saving/renaming, sync to server
          setTimeout(() => { saveActiveToServer(app, {ensureJupyterSaved:false}); }, 300);
        }
      });
    }
    document.getElementById('saveBtn').onclick = () => { saveActiveToServer(app, {ensureJupyterSaved:true}); };
  }

  (async () => {
    await ensurePerUserStorage();

    // Load Lite (same-origin) AFTER isolation
    frame.src = "{{ url_for('static', filename='jlite/lab/index.html') }}?reset";
    frame.addEventListener("load", async () => {
      const app = await waitForAppReady(60000);
      if (!app){
        // background retry without scaring the user
        const timer = setInterval(async () => {
          const a2 = await waitForAppReady(5000);
          if (a2){
            clearInterval(timer);
            installSaveHooks(a2);
            const id = new URLSearchParams(window.location.search).get("import");
            if (id) await importFromServer(a2, parseInt(id, 10));
          }
        }, 1000);
        return;
      }

      installSaveHooks(app);
      const id = new URLSearchParams(window.location.search).get("import");
      if (id) await importFromServer(app, parseInt(id, 10));
    });
  })();
})();
</script>
{% endblock %}
