{% extends "base.html" %}
{% block content %}
<h2>Jupyter Notebooks (Lite)</h2>
<p class="muted">
  Save with <em>Save to Server</em> or Jupyter’s Save (Ctrl+S).
  If this notebook is a homework, you’ll also see <em>Submit Homework</em>.
</p>

<div style="margin:0 0 10px 0;">
  <button id="saveBtn" class="btn">Save to Server</button>
  <button id="submitBtn" class="btn btn-danger" style="display:none">Submit Homework</button>
  <span id="status" style="margin-left:10px;color:#9ecbff;"></span>
</div>

<div style="height:82vh;">
  <iframe
    id="jlite_frame"
    title="JupyterLite"
    src="about:blank"
    style="width:100%;height:100%;border:0"
    allow="clipboard-read; clipboard-write">
  </iframe>
</div>

<script>
(function(){
  const STATUS = document.getElementById('status');
  const frame = document.getElementById('jlite_frame');
  const submitBtn = document.getElementById('submitBtn');
  const saveBtn = document.getElementById('saveBtn');
  const sleep = ms => new Promise(r => setTimeout(r, ms));

  let serverSaveBusy = false;
  let initHooksDone = false;
  let currentHomeworkCode = null; // if non-null, active file is a homework

  function setStatus(msg, isError=false, ttl=3000){
    STATUS.textContent = msg || '';
    STATUS.style.color = isError ? '#ff8a80' : '#9ecbff';
    if (msg && ttl) setTimeout(()=>{ STATUS.textContent=''; }, ttl);
  }

  // -------- storage helpers (same as before) --------
  async function clearJupyterLiteStorage(){
    try{
      if (typeof indexedDB.databases === 'function') {
        const dbs = await indexedDB.databases();
        for (const db of dbs) if (db && db.name) {
          await new Promise(res => {
            const req = indexedDB.deleteDatabase(db.name);
            req.onsuccess = req.onerror = req.onblocked = () => res();
          });
        }
      } else {
        for (const name of [
          "JupyterLite Storage","JupyterLite","JupyterLite v1",
          "JupyterLite Contents","JupyterLab Workspaces","jupyterlite","jp-contents"
        ]) {
          await new Promise(res => {
            const req = indexedDB.deleteDatabase(name);
            req.onsuccess = req.onerror = req.onblocked = () => res();
          });
        }
      }
    }catch(_){}
    try{
      if ('caches' in window) {
        const keys = await caches.keys();
        for (const k of keys) if (k.toLowerCase().includes('jupyter')) {
          await caches.delete(k).catch(()=>{});
        }
      }
    }catch(_){}
    try{
      for (const k of Object.keys(localStorage)) if (/jupyter|jp-|jupyterlab|jupyterlite/i.test(k)) localStorage.removeItem(k);
      for (const k of Object.keys(sessionStorage)) if (/jupyter|jp-|jupyterlab|jupyterlite/i.test(k)) sessionStorage.removeItem(k);
    }catch(_){}
  }
  window.addEventListener('pagehide', () => { clearJupyterLiteStorage(); });
  window.addEventListener('beforeunload', () => { clearJupyterLiteStorage(); });

  async function waitForAppReady(maxMs=60000){
    const win = frame.contentWindow;
    const start = Date.now();
    while (Date.now() - start < maxMs){
      const app = win && win.jupyterapp;
      if (app && app.serviceManager && app.serviceManager.ready){
        try { await app.serviceManager.ready; } catch(_){}
        return app;
      }
      await sleep(100);
    }
    return null;
  }

  function baseName(pth){ return (pth || '').split('/').pop() || 'Untitled.ipynb'; }
  function sanitizeName(name){
    let n = (name || 'Untitled').trim();
    n = n.replace(/[\\\/:*?"<>|]/g, '-');
    if (!n.toLowerCase().endsWith('.ipynb')) n += '.ipynb';
    return n;
  }

  async function getCSRF(){
    const r = await fetch("/api/csrf", {credentials:"same-origin"});
    const j = await r.json(); return j.csrf;
  }

  // Clean workspace before opening an imported notebook
  async function cleanWorkspace(app){
    const contents = app.serviceManager.contents;
    async function deleteTree(path){
      const model = await contents.get(path || '', {content: true}).catch(()=>null);
      if (!model) return;
      if (model.type === 'directory'){
        for (const child of (model.content || [])){ await deleteTree(child.path); }
        if (path) await contents.delete(path).catch(()=>{});
      } else if (path) {
        await contents.delete(path).catch(()=>{});
      }
    }
    const root = await contents.get('', {content:true}).catch(()=>null);
    if (root && Array.isArray(root.content)){
      for (const item of root.content){ await deleteTree(item.path); }
    }
  }

  // ---- Homework detection & UI ----
  async function detectHomeworkAndUpdateUI(app){
    currentHomeworkCode = null;
    submitBtn.style.display = 'none';
    submitBtn.disabled = false;

    const w = app.shell.currentWidget;
    if(!w || !w.context || !w.context.path) return;

    // read notebook JSON to see if it has homework_code
    const model = await app.serviceManager.contents.get(w.context.path, {content:true, type:"notebook", format:"json"}).catch(()=>null);
    if (!model || !model.content) return;
    const nb = model.content;
    const md = nb.metadata || {};
    const code = (md.homework_code || '').trim();

    if (!code) return; // not a homework
    currentHomeworkCode = code;
    submitBtn.style.display = 'inline-block';

    // Check server status to disable if already submitted
    try{
      const res = await fetch(`/api/hw/${code}/status`, {credentials:'same-origin'});
      if (res.ok){
        const j = await res.json();
        if (j.submitted){
          submitBtn.disabled = true;
          setStatus("This homework is already submitted (read-only).", true, 4000);
        }
      }
    }catch(_){}
  }

  async function importFromServer(app, nbId){
    await cleanWorkspace(app);
    const r = await fetch(`/api/notebooks/${nbId}`, {credentials:"same-origin"});
    if(!r.ok){ setStatus("Could not load notebook.", true); return; }
    const data = await r.json();
    const nb = data.content || {};
    nb.metadata = nb.metadata || {};
    // IMPORTANT: Set chalk_id so subsequent saves update the same notebook instead of creating duplicates
    nb.metadata.chalk_id = nbId;
    // Use stored filename (or metadata), not imported-*.ipynb
    const desired = sanitizeName(data.name || nb.metadata.chalk_name || `Notebook-${nbId}.ipynb`);
    const contents = app.serviceManager.contents;
    await contents.delete(desired).catch(()=>{});
    await contents.save(desired, {type:"notebook", format:"json", content: nb});
    await app.commands.execute('docmanager:open', { path: desired });

    await detectHomeworkAndUpdateUI(app);
  }

  // Save active notebook — route to HW API if it's a homework
  async function saveActiveToServer(app, {ensureJupyterSaved} = {ensureJupyterSaved:true}){
    if (serverSaveBusy) return;
    const w = app.shell.currentWidget;
    if(!w || !w.context || !w.context.path){
      setStatus("No active notebook.", true); return;
    }
    try{
      serverSaveBusy = true;
      if (ensureJupyterSaved) { await w.context.save(); }
      await sleep(180);

      const path = w.context.path;
      const model = await app.serviceManager.contents.get(path, {content:true, type:"notebook", format:"json"});
      const nb = model && model.content;
      if(!nb){ setStatus("Could not read notebook JSON.", true); return; }

      const chosen = sanitizeName(baseName(path));
      nb.metadata = nb.metadata || {};
      nb.metadata.chalk_name = chosen;

      const csrf = await getCSRF();

      // If this is a homework, save via the homework API (enforces locking)
      const code = (nb.metadata.homework_code || '').trim();
      if (code){
        const res = await fetch(`/api/hw/${code}/save`, {
          method: "PUT",
          headers: {"Content-Type":"application/json","X-CSRF": csrf},
          credentials: "same-origin",
          body: JSON.stringify({ content: nb })
        });
        if(!res.ok){
          if (res.status === 403) setStatus("Homework is locked (cannot save).", true);
          else setStatus("Save failed.", true);
          return;
        }
        setStatus(`Saved: ${chosen}`, false, 1500);
      } else {
        // Regular personal notebook
        const id = (nb.metadata && nb.metadata.chalk_id) ? nb.metadata.chalk_id : null;
        if (!id){
          const resp = await fetch('/api/notebooks', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'X-CSRF': csrf },
            credentials: 'same-origin',
            body: JSON.stringify({ content: nb })
          });
          if (!resp.ok) { setStatus('Create failed.', true); return; }
          const data = await resp.json();
          nb.metadata.chalk_id = data.id;
          await app.serviceManager.contents.save(path, {type:"notebook", format:"json", content: nb});
          setStatus(`Saved (new): ${chosen}`, false, 2000);
        } else {
          const resp = await fetch(`/api/notebooks/${id}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json', 'X-CSRF': csrf },
            credentials: 'same-origin',
            body: JSON.stringify({ content: nb })
          });
          if (!resp.ok) { setStatus('Update failed.', true); return; }
          setStatus(`Saved: ${chosen}`, false, 1500);
        }
      }
    } catch(e){
      console.error(e);
      setStatus("Save failed.", true);
    } finally {
      serverSaveBusy = false;
    }
  }

  async function submitHomework(app){
    if (!currentHomeworkCode) return;
    // force a last save through HW path, then submit
    await saveActiveToServer(app, {ensureJupyterSaved:true});
    const csrf = await getCSRF();
    const res = await fetch(`/api/hw/${currentHomeworkCode}/submit`, {
      method: "POST",
      headers: {"X-CSRF": csrf},
      credentials: "same-origin"
    });
    if (!res.ok){
      setStatus("Submit failed.", true);
      return;
    }
    // lock UI and clear storage
    submitBtn.disabled = true;
    setStatus("Submitted. This homework is now locked.", false, 4000);
    await clearJupyterLiteStorage();
  }

  function installHooks(app){
    if (initHooksDone) return;
    initHooksDone = true;

    // Save button
    saveBtn.onclick = () => { saveActiveToServer(app, {ensureJupyterSaved:true}); };

    // Submit button (shown only when a homework is detected)
    submitBtn.onclick = () => { submitHomework(app); };

    // Follow Jupyter's saves/renames/opens to autosync and refresh homework UI
    const cmds = app.commands;
    if (cmds && cmds.commandExecuted && cmds.commandExecuted.connect){
      cmds.commandExecuted.connect((_s, args) => {
        const id = args && args.id;
        if (id === 'docmanager:save' || id === 'docmanager:save-as' || id === 'docmanager:save-all' || id === 'docmanager:rename'){
          setTimeout(() => {
            saveActiveToServer(app, {ensureJupyterSaved:false});
            detectHomeworkAndUpdateUI(app);
          }, 300);
        }
        if (id === 'docmanager:open'){
          setTimeout(() => { detectHomeworkAndUpdateUI(app); }, 200);
        }
      });
    }

    // Also react when the active tab changes
    if (app.shell && app.shell.currentChanged && app.shell.currentChanged.connect){
      app.shell.currentChanged.connect(() => { void detectHomeworkAndUpdateUI(app); });
    }
  }

  (async () => {
    // Load Lite
    frame.src = "{{ url_for('static', filename='jlite/lab/index.html') }}";
    frame.addEventListener("load", async () => {
      const app = await waitForAppReady(60000);
      if (!app){
        const timer = setInterval(async () => {
          const a2 = await waitForAppReady(5000);
          if (a2){ clearInterval(timer); installHooks(a2); const id = new URLSearchParams(window.location.search).get("import"); if (id) await importFromServer(a2, parseInt(id, 10)); await detectHomeworkAndUpdateUI(a2); }
        }, 1000);
        return;
      }
      installHooks(app);
      const id = new URLSearchParams(window.location.search).get("import");
      if (id) await importFromServer(app, parseInt(id, 10));
      await detectHomeworkAndUpdateUI(app);
    });
  })();
})();
</script>
{% endblock %}
